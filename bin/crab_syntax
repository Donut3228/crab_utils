#!/bin/bash

set -eu

. /opt/crab/crab_utils/bin/::carbon.sys

sys::usage "$@"
# --help Info:
# --help Утилита проверки синтаксиса и ошибок bash в стиле set -eu
# --help обязательна для всех новых файлов с 2017 года
# --help для старых файлов переход на set -eu разрешен только после написания func/unit теста
# --help test-имя, в котором тестируется _весь_ функционал скрипта в чистых и ошибочных ситуациях
# --help Usage:
# --help crab_syntax $filename|$dir bash|cc|python|html|xml
# --help Example:
# --help crab_syntax myfile.sh
# --help crab_syntax myfile.sh bash

# Проверка базовых правил.
maybe=0

if [ "${1:-}" = "--maybe" ]; then
	maybe=1
	shift
fi

syntax_style=${2:-bash}

if [ -d "$1" ]; then
	DIR="$1"
	failed=FALSE
	while read -r f; do
		if ! head -n1 "$f" | grep -qm1 '#!/bin/bash'; then
			continue
		fi
		if ! /opt/crab/crab_utils/bin/crab_syntax "$f"; then
			failed=TRUE
		fi
	done< <( find "$DIR"/* -type f )
	[ $failed = TRUE  ] && { echo FAILED; exit 1; }
	exit 0
fi

if [ "$syntax_style" != "bash" ]; then
	echo "not supported \"$syntax_style\" yet. plz add new style"
	exit 0
fi

__SPACE=$' \t'
__EMPTY=''
F=$1

if grep '^[#$__SPACE]* skip crab_syntax' "$F"; then
	echo SKIP
	exit 0
fi

ERROR=0
error_msg=""

ALL_FUNCS=$( cat "$F" \
	| grep '^.*()' \
	| sed -n  's/^\(\S*\)().*{/\1/p' ) || true # '

echo_error(){
	ERROR=$((ERROR+1))
	echo -e "^^^ERROR $@"
	echo
	return 0
}

strongbash001(){
	### crab_indent
	cp -f "$F" /tmp/crab_syntax_check.$$
	chmod 666 /tmp/crab_syntax_check.$$
	crab_indent /tmp/crab_syntax_check.$$ "$syntax_style" &>/tmp/crab_indent_out.$$
	if ! cmp /tmp/crab_syntax_check.$$ "$F"; then
		cat /tmp/crab_indent_out.$$
		echo_error 'strongbash001 Не выполнен crab_indent'
	fi
	rm -f /tmp/crab_indent_out.$$
	rm -f /tmp/crab_syntax_check.$$
	return 0
}

strongbash002(){
	if ! head -n 10 "$F" | egrep -qm1 '^(# )?set -euEo pipefail' \
		&& ! grep -qm1 '::carbon.sys' "$F"; then
		echo_error\
			'strongbash002 Не установлен set -euEo pipefail '\
			'как работать с pipefail: a|b|c|d || true '
	fi
	return 0
}

strongbash003(){
	egrep -n '^[^#].*(if|&&|\|\|).* \|\| true' "$F" &&\
		echo_error 'strongbash003 Нельзя использовать || true в условных выражениях'
	return 0
}

strongbash004(){
	grep -n 'else' -A 1 "$F" | egrep "^[0-9$__SPACE-]*true" \
		&& echo_error 'strongbash004 Нельзя использовать else true в условных выражениях'
	return 0
}

strongbash005(){
	### todo обрабатывать отдельно каждую функцию
	count_func=$( grep '()[ ]*{' "$F" | wc -l || true ) # '
	count_end_return=$( grep 'return\|exit' -A 1 "$F" | grep '^}' | wc -l || true )
	[ $count_func != $count_end_return ] \
		&& echo_error \
		'strongbash005 $count_func!=$count_end_return В конце каждой функции должен быть '\
		'return 0 или return $ret или exit'
	return 0
}

strongbash006(){
	if ! tail -n 2 "$F" | head -n 1 | grep -q '$0 $@ \[$$\] SUCCESS'\
		|| ! grep -q '$0 $@ \[$$\] START' "$F"; then
		grep -qm1 '::carbon.sys' "$F" && return 0
		echo_error 'strongbash006 В начале каждого файла должен быть:
		echo "$0 $@ [$$] START" >&2
		BODY
		В конце каждого файла должен быть:
		echo "$0 $@ [$$] SUCCESS" >&2
		exit 0

		или для тихих:
		# echo "$0 $@ [$$] SUCCESS"
		или для библиотек:
		# exit 0

		или используйте:
		. ::carbon.sys
		BODY
		exit 0
		'
	fi
	return 0
}

strongbash007(){
	if ! tail -n 1 "$F" | grep -q 'exit 0'; then
		echo_error 'strongbash007 В конце каждого файла должен быть:
		exit 0
		или для библиотек:
		# exit 0
		'
	fi
	return 0
}

strongbash008(){
	head -n 1 "$F" | grep -qm1 '#!/bin/bash' \
		|| echo_error 'strongbash008 Обязательно использовать #!/bin/bash даже в include'
	return 0
}

strongbash009(){
	egrep -n '\blet\b[^.]*=.*' "$F" \
		&& echo_error \
		'strongbash009 Нельзя использовать let тк дает ошибку при переходе через 0. Используйте $(())'
	return 0
}

strongbash010(){
	cat "$F" | grep -v strongbash010 | grep -v 'DIR\|dir' | grep -P -n '^[^#\s]*=/tmp/' \
		&& echo 'WARNING ^^^ strongbash010 Не рекомендуется использовать' \
		'глобальные переменные для временных файлов,' \
		'лучше локальные local tt=/tmp/binname_tmpcat.$$' \
		'или глобальный каталог mkdir -p $TMPDIR $TMPDIR/testfile.txt'
	if egrep -q '^[^#]*rm.*/tmp/.*' "$F" && \
		! egrep '^[^#]*rm.*/tmp/.*' "$F" | fgrep -qm1 '$$'; then
		egrep -n 'rm.*/tmp/.*' "$F"
		echo_error 'strongbash011 Нельзя использовать временные файлы без $$, '\
			'лучше rm -f /tmp/binname_tmpcat.$$'
	fi
	return 0
}

strongbash011(){
	indent_max=0
	indent_max_lnum=0
	local l=0
	while IFS='' read -r line; do
		l=$((l+1))
		indent=$( echo "$line" | sed 's/        /\t/' \
			| sed 's/\t/        /g' \
			| sed -n 's/^\([ ]\{1,\}\)\([^ ].*\)$/\1/p' \
			| wc -m || true ) # '
		indent=$((indent/8))
		(( $indent > $indent_max )) && { indent_max="$indent"; indent_max_lnum=$l; }
	done < "$F"

	if (( $indent_max > 5 )); then
		grep -n . "$F" | grep "^$indent_max_lnum:"
		echo_error \
			"strongbash011 слишком большая глубина(indent=$indent_max), "\
			"используйте ранний return или сделайте подфункции"
	fi
	return 0
}

strongbash012(){
	grep -n '.*|[ ]*[\]$' "$F"  \
		&& echo_error 'strongbash012 pipe в "| \" требуется вынести на следующую строку.
	Пример:
	cat 123 | grep 123 \
		| while read -r t; do echo 123; done
	'
	return 0
}

strongbash013(){
	grep -n "^[$__SPACE]*#[^$__SPACE!#{}]." "$F" \
		&& echo_error 'strongbash013 ставьте пробел после # или используйте #} #{ для ошибок indent'
	return 0
}

MAX_FSIZE=64
strongbash014(){
	local n=0
	local fstart=0
	local fsize=0
	local fsize_error=FALSE
	local fstart_line=''
	while IFS='' read -r line; do
		n=$((n+1))
		if [[ "$line" == *'()'*'{' ]]; then
			fstart=$n
			fstart_line=$line
		fi
		if [[ "$line" == '{' ]]; then
			fstart=$n
			fstart_line=$line
		fi
		if (( $fstart > 0 )); then
			echo "$line" | grep -qm1 "^[$__SPACE]*#.*" && continue
			fsize=$(( fsize+1 ))
			if [[ "$line" == '}'* ]]; then
				if (( $fsize > $MAX_FSIZE )); then
					echo "$fstart: fsize=$fsize $fstart_line"
					fsize_error=TRUE
				fi
				fstart=0
				fstart_line=
				fsize=0
			fi
		fi
	done < "$F"
	[ $fsize_error = TRUE ] \
		&& echo_error \
		"strongbash014 Слишком большая функция больше $MAX_FSIZE строк, "\
		"выделите подфункции __fname"
	return 0
}

strongbash015(){
	fsize=$(cat "$F" | wc -l )
	fcomm_size=$( grep "^[$__SPACE]*#.*" "$F" | wc -l || true )
	fcount=$( grep '()[ ]*{*' "$F" | wc -l || true ) # ' #}
	[ "$fcount" -gt 1 ] && fcount=$(( fcount/2 )) # 32 строк на ф
	avg_size=$(((fsize-fcomm_size)/(1+fcount)))
	if [[ "$avg_size" -gt "$MAX_FSIZE" ]]; then
		echo_error \
			"strongbash015 Слишком большой линейный файл" \
			"$(((fsize-fcomm_size)/fcount)) больше $MAX_FSIZE строк, "\
			"разбейте на функции"
	fi
	return 0
}

strongbash016(){
	egrep -n ".*[$__SPACE]\$" "$F" \
		&& echo_error 'strongbash016 Уберите конечные пробелы и tab'
	return 0
}

MAX_CHARS=100
strongbash017(){
	while IFS='' read -r line; do
		chars_count=$( echo "$line" | wc -m  || true )
		if [ $chars_count -gt $MAX_CHARS ]; then
			echo "$line"
			echo_error \
				"strongbash017 длина строки больше $MAX_CHARS используйте перенос \\ "\
				"примеры переносов:\necho_suc \"aaaaaaaaaaaaaaaaaa\"\\ \n\"bbbbbbbb\" "
		fi
	done < "$F"
	return 0
}

strongbash018(){
	egrep -n  "^[$__SPACE]*[^#$__SPACE]+.*[^ 0-9)&>$__SPACE]>[ ]*+[^ \$\"'[]+"  "$F" \
		&& echo_error 'strongbash018 поставьте пробел перед "text >oo"'
	return 0
}

strongbash019(){
	if ! grep -qm1 "Info:"  "$F" \
		|| ! grep -qm1 "Usage:"  "$F" \
		|| ! grep -qm1 "Example:"  "$F"; then
		echo_error \
"strongbash019
Добавьте обязательно:
if [ \${1:---help} = --help ]; then
echo Info: копирует файл со сжатием на внешний сервер
echo Usage: ${F##/*} [--verbose] [-z 0-9] src|srcdir dst|host:dst
echo Example: ${F##/*} --verbose -z 9 myfile1.txt example.com
Или sys::usage \"\$@\"
### -$__EMPTY-help Info:
### -$__EMPTY-help Usage:
### -$__EMPTY-help Example:"
	fi
	return 0
}

strongbash020(){
	for func in $ALL_FUNCS; do
		if [[ "${func^^}" == *LOG* ]]; then
			if grep -A 1000000 "$func" "$F" | grep -B100000 -m1 '^}' \
				| grep -n 'date'; then
				echo_error "strongbash020 Запрещены функции Log в утилитах"
			fi
		fi
	done
	return 0
}

list_tmpvar1=$( grep -P '^\s*\w*="{0,1}/tmp/.*"{0,1}' "$F" \
	| sed -n 's/\(.*\W\|^\)\(\w*\)=.*/\2/p' || true )

list_tmpvar2=$( grep -P '^\s*\w*=.*[(`]\s*mktemp.*' "$F" \
	| sed -n 's/\(.*\W\|^\)\(\w*\)=.*/\2/p' || true )

grep_list_tmpvar="$list_tmpvar1 $list_tmpvar2"
grep_list_tmpvar="${grep_list_tmpvar//[ $'\n']/|}"

strongbash021_1(){
	if grep -n -P 'trap.*rm.*tmp.*(EXIT|0).*' "$F"; then
		echo_error "strongbash021_1 запрещено удалять tmp в trap EXIT"
	fi
	return 0
}

strongbash021_2(){
	if grep -n -P "trap.*rm.*($grep_list_tmpvar).*(EXIT|0).*" "$F"; then
		echo_error "strongbash021_2 запрещено удалять tmp в trap EXIT"
	fi
	return 0
}

strongbash021_3(){
	for func in $ALL_FUNCS; do
		if grep -q "trap.*$func.*" "$F"; then
			if grep -A 1000000 "$func" "$F" | grep -B100000 -m1 '^}' \
				| grep -n '.*rm.*tmp'; then
				echo_error "strongbash021_3 запрещено удалять tmp в trap EXIT"
			fi
		fi
	done
	return 0
}

strongbash021_4(){
	for func in $ALL_FUNCS; do
		if grep -q "trap.*$func.*" "$F"; then
			if grep -A 1000000 "$func" "$F" | grep -B100000 -m1 '^}' \
				| grep -P -n ".*rm.*($grep_list_tmpvar).*"; then
				echo_error "strongbash021_4 запрещено удалять tmp в trap EXIT"
			fi
		fi
	done
	return 0
}

strongbash021_5(){
	if grep -n -P 'trap.*(EXIT|0).*' "$F"; then
		echo "WARNING ^^^ strongbash021_5 не рекомендуется использовать trap EXIT"
	fi
	return 0
}

strongbash022_1(){
	for var in $list_tmpvar1; do
		if ! grep -qm1 -P "^([^#].*|)rm.*$var" "$F"; then
			echo_error "strongbash022_1" \
				"утилиты должны удалять за собой временные файлы rm -f \"\$$var\""\
				"или работать c постоянными файлами в /var/"
		fi
	done
	return 0
}
strongbash022_2(){
	for var in $list_tmpvar2; do
		if ! grep -qm1 -P "^([^#].*|)rm.*$var" "$F"; then
			echo_error "strongbash022_2" \
				"утилиты должны удалять за собой временные файлы rm -f \"\$$var\""\
				"или работать c постоянными файлами в /var/"
		fi
	done
	return 0
}

strongbash023_1(){
	if grep -P -n '^([^#].*\s|)read(?!.*-r).*' "$F"; then
		echo_error "strongbash023_1"\
			'нужно всегда использовать read -r f1 f2'
	fi
	return 0
}

strongbash023_2(){
	if grep -P -n '^([^#].*\s|)while [r]ead.*line' "$F"; then
		echo_error "strongbash023_2"\
			'для чтения целой строки while IFS='' read -r line; do'
	fi
	return 0
}

strongbash024_1(){
	if grep -P -n '^(?![#]).*rm -r[f]*\s.*"[.]*\/\$' "$F"; then
		echo_error "strongbash024_1"\
			'Запрещено r''m -rf "/$dir" "./$dir" "$dir*" "$dir/*" "$dir/"'
	fi
	return 0
}

strongbash024_2(){
	if grep -P -n '^(?![#]).*rm -r[f]*\s.*"\$\S*\w[*]' "$F"; then
		echo_error "strongbash024_2"\
			'Запрещено r''m -rf "/$dir" "./$dir" "$dir*" "$dir/*" "$dir/"'
	fi
	return 0
}
strongbash024_3(){
	if grep -P -n '^(?![#]).*rm -r[f]*\s.*"\$\S*\/' "$F"; then
		echo_error "strongbash024_3"\
			'Запрещено r''m -rf "/$dir" "./$dir" "$dir*" "$dir/*" "$dir/"'
	fi
	return 0
}

strongbash024_4(){
	if grep -n -P '^(?![#])rm(?!.*-one-file-system.*).*-r.*' "$F"; then
		echo_error "strongbash024_4"\
			'Запрещено r''m -rf без -one-file-system '
	fi
	return 0
}

strongbash025(){
	if egrep -n '^\s*(do|then)(\s+.*|$)' "$F"; then
		echo_error "strongbash025 'do' и 'then' НЕ делаем c новой строки"
	fi
	return 0
}

strongbash026(){
	if egrep -n '^[^#].* \]+$' "$F"; then
		echo_error "strongbash026 нельзя использовать голые скобки для assert и тп [ a = b ]"
	fi
	return 0
}

strongbash027(){
	if grep -P -n '^(?!(.*if|[^\|]*&&))[^#].*\S+\s*\|\|(?!.*true).*' "$F"; then
		echo_error \
"strongbash027 нельзя использовать конструкции вида [ a = b ] |$__EMPTY| cmd1
и cmd1 |$__EMPTY| cmd2
кроме утвержденного сахара
используйте [ a != b ] && cmd1"

	fi
	return 0
}

strongbash028(){
	local t=""
	if grep -P -n '^[^#].*[\w|\s]*\|\|[\w|\s]*\|\|[\w|\s]*.*' "$F"; then
		echo_error "strongbash028 нельзя использовать \
			cmd1 |$__EMPTY| cmd2 |$__EMPTY| cmd3"
	fi
	return 0
}

strongbash029(){
	for fname in $ALL_FUNCS; do
		if egrep -qm1 ".*\\$\([ ]*$fname([ ].*|[ ]*)\).*" "$F" \
			&& ! egrep -A 1 "^$fname\(\).*\{" "$F" | grep -qm1 'set -e'; then
			egrep -n ".*\\$\([ ]*$fname([ ].*|[ ]*)\).*" "$F"
			echo_error "strongbash029 добавьте set -e в первую строку функции $fname ,"\
				"которая используется в конструкции \$( $fname )"
		fi
	done
	return 0
}

strongbash030_1(){
	for fname in $ALL_FUNCS; do
		if egrep -n "(^|.*\W)$fname[ ]*&&.*" "$F" ; then
			echo_error "strongbash030_1 нельзя использовать $fname && cmd1"
		fi
	done
	return 0
}

strongbash030_2(){
	for fname in $ALL_FUNCS; do
		if egrep -n "(^|.*\W)$fname[ ]*\|\|.*" "$F" ; then
			echo_error "strongbash030_2 нельзя использовать $fname |$__EMPTY| cmd1"
		fi
	done
	return 0
}

strongbash030_3(){
	for fname in $ALL_FUNCS; do
		if egrep -n ".*if.*\s$fname\W+.*" "$F" ; then
			echo_error "strongbash030_3 нельзя использовать if $fname; then"
		fi
	done
	return 0
}

###
self_skip='strongbash021_1 strongbash021_2 strongbash021_3 strongbash021_4 strongbash021_5'
if [ $maybe == 1 ]; then
	strongbash001
	strongbash002
	strongbash006
	strongbash017
else
	for check in $( typeset -F | grep strongbash[0-9][0-9][0-9] | sed 's/declare -f //' || true ); do
		if [[ "${0##*/}" == "crab_syntax" ]]; then
			[[ " $self_skip " == *" $check "* ]] && continue
		fi
		$check
	done
fi

[ "$error_msg" != "" ]  && echo -e "$error_msg"
[ $ERROR != 0  ] && { echo FAILED; exit 1; }
exit 0
