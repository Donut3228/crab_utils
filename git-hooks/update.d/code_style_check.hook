#!/bin/bash
set -euEo pipefail
# set -x

echo "$0 $@ [$$] START" >&2


store_success_file() {
	# Сохраним успешно проверенные файлы для будущих свершений.
	local file="$1"
	local cwd=$(pwd)
	local repo_name=${cwd##*/}
	local store_dir="$STORE_SUCCESS_DIR"/"$repo_name"
	
	if [ ! -d "$store_dir" ]; then
		mkdir -p "$store_dir"
	fi
	# /./ нужна для rsync, чтобы он корректно создал структуру путей.
	rsync -aR $TMP_NEW_WORK_DIR/./"$file" "$store_dir"
	return 0
}


get_file_type() {
	# Определим тип файла. Вернём в stdout
	# Возвращаемый тип, должен поддерживаться crab_syntax
	# Возвращаем только те типы, которые надо проверять.
	local file="$1"
	local file_type;

	file_mime_type=$(file -bi "$file")

	case "$file_mime_type" in
	text/x-shellscript*)
		echo bash
		;;
	# text/x-python*)
	#	echo python
	#	;;
	esac
	return 0
}


check_file() {
	# Проверка codestyle
	local file="$1"
	local file_type="$2"
	local is_new="${3:-}"
	
	# Проверять наличие старого файла не катит.
	# Файл извлекается, даже если его на указанный коммит не существовало.
	# if [ ! -f $TMP_OLD_WORK_DIR/"$file" ]; then  
	if [ -n "$is_new" ]; then
		need_check=1
	else
		# "Умная" проверка, если файл уже был в репозитории раньше.
		# Если файл был, то это значит,
		#   что он добавлен после хука и полностью прошёл проверку.
		# Либо он был до внедрения хука и его соответствие code style неизвестно.
		# Если старый или новый файлы соответствует базовым правилам карбон,
		#   то тогда делаем полный чек.
		# Иначе считаем файл legacy и не соответствующим правилам карбон.
		#   Молча закрывая глаза на legacy.
		#
		# Не нравится мне гасить вывод предварительных проверок.
		# Но выводить пользователю кашу из 3-х проверок одного файла, тоже перебор.
		# !!! Пока опция --maybe не работает, то проверка скипается.
		if crab_syntax --maybe $TMP_OLD_WORK_DIR/"$file" "$file_type" \
		&> $TMP_WORK_DIR/crab_maybe_old \
		|| crab_syntax --maybe $TMP_NEW_WORK_DIR/"$file" "$file_type" \
		&> $TMP_WORK_DIR/crab_maybe_new; then
			need_check=1
		else
			echo "$myname: Skip Legacy file check."
		fi
	fi

	if [ "$need_check" = "1" ]; then
		# set -e внутри проверочных функций не работает, трап вручную.
		echo "$myname: crab_syntax $TMP_NEW_WORK_DIR/"$file" "$file_type""
		crab_syntax $TMP_NEW_WORK_DIR/"$file" "$file_type" || return 1
		# результат сохранения не чекаем, т.к. это не главный функционал.
		# возможные проблемы будут видны в stderr.
		store_success_file "$file"
	fi
	return 0
}


myname=${0##*/}

# API git хуков подразумевает 3 параметра:
if [ "${1:-}" = "--help" ] || [ $# != 3 ]; then
	echo "Example: (cd <git_dir> && $0 <refname> <old_commit> <new_commit>; )"
	echo "Today Hash: "
fi
ref=$1
old_commit=$2
new_commit=$3

# Magic check disabling
if [ -f /etc/git_secure_salt ]; then
	MAGIC_SALT=$(</etc/git_secure_salt)  # или сделать конфиг.
else
	MAGIC_SALT='salt'
fi
read -r MAGIC_FORCE_STR tmp_tail < <(echo "${MAGIC_SALT}$(date +%Y%m%d)" | md5sum)


# echo "Hook params $*"
CHECK_ERR_COUNT=0  # счётчик файлов не прошедших проверку.

TMP_WORK_DIR=/tmp/${myname}.$$  # may be trap on conflict.
TMP_NEW_WORK_DIR=$TMP_WORK_DIR/new
TMP_OLD_WORK_DIR=$TMP_WORK_DIR/old
STORE_SUCCESS_DIR=/home/gitlab/code_style_check_store  # unportable hardcode. TODO: сделать конфиг!

mkdir -p $TMP_WORK_DIR $TMP_NEW_WORK_DIR $TMP_OLD_WORK_DIR

if [ ! -d $STORE_SUCCESS_DIR ]; then
	mkdir -p $STORE_SUCCESS_DIR
fi


if git log -n 1 $new_commit | grep -qm1 $MAGIC_FORCE_STR; then
	echo "$myname: Force commit push! Skip check."
	exit 0
fi


# История изменения файлов между актуальной версией ветки(old) и запушенной(new).
git log $'--pretty=format:commit\t%H' --name-status --reverse \
	$old_commit..$new_commit > $TMP_WORK_DIR/git_log
while IFS=$'\t' read -r mode file any_tail; do
	# if [ "$mode" == "commit" ]; then
	#	commit=$file
	#	echo "Check commit $commit"
	# elif

	# D - удалённые, A - новые, M - изменённые файлы.
	if [ "$mode" == "A" ] || [ "$mode" == "M" ]; then
		# Если файл есть во временной папке, значит мы его уже проверили.
		if [ -f $TMP_NEW_WORK_DIR/"$file" ]; then
			echo "$myname: Done file: $file, skip."
			continue
		fi
		if [ "$mode" == "A" ]; then
			echo "$myname: Added file: $file"
			is_new=1
		else
			echo "$myname: Modified file: $file"
			is_new=
		fi
		echo "$myname: Extract $file"
		# Считаем, что checkout может дать ошибку, если файла уже нет в репе.
		# И это нормальная ситуация. Потому игнорим ошибки checkout
		# !! Если файл новый, то он же и извлекается по запросу на старый коммит.
		# Нужно разбираться в поведении checkout
		git_checkout $new_commit "$file" $TMP_NEW_WORK_DIR
		git_checkout $old_commit "$file" $TMP_OLD_WORK_DIR
		# mk func
		# git --work-tree=$TMP_NEW_WORK_DIR checkout $new_commit -- "$file" || true
		# git --work-tree=$TMP_OLD_WORK_DIR checkout $old_commit -- "$file" || true

		## Если файла в репе уже нет, то и проверять нечего.
		if [ ! -f $TMP_NEW_WORK_DIR/"$file" ]; then
			continue
		fi

		file_type=$(get_file_type $TMP_NEW_WORK_DIR/"$file")
		# Если тип не поддерживается нами, то не проверяем.
		if [ -z "$file_type" ]; then
			continue
		fi

		echo "$myname: check $file_type file $file new $is_new"
		check_file "$file" "$file_type" "$is_new"
	fi  # if new_file
done < $TMP_WORK_DIR/git_log

# FORCE - secret, делать через Колю1
# if [ $ret != 0 ]; then
#	cat <<EOF
# $myname: Push declined.
# $myname: For force, include '$MAGIC_FORCE_STR' in failed bash script as comment.
# $myname: Or use last commit message with '$MAGIC_FORCE_STR':
# $myname:     git commit -m "$MAGIC_FORCE_STR" --allow-empty
# $myname:     git push
# EOF
# fi
# echo "$myname exit $ret."

rm -r $TMP_WORK_DIR

if [ $CHECK_ERR_COUNT != 0 ]; then
	echo "RTFM http://opencarbon.ru/"\
	"%D1%81%D0%BE%D0%B3%D0%BB%D0%B0%D1%88%D0%B5%D0%BD%D0%B8%D1%8F"\
	"_%D0%BA%D0%BE%D0%B4%D0%B0:strongbash#"
	echo "or GOTO admin."
	echo "$0 $@ [$$] CHECK FAILED, $CHECK_ERR_COUNT files with errors." >&2
fi

echo "$0 $@ [$$] SUCCESS" >&2
exit 0
